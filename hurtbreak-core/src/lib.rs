/// Re-export of the derive macro for `Fuzzable` trait.
///
/// This macro automatically implements fuzzing methods for struct fields
/// based on their types and `#[fuzz]` attributes.
pub use hurtbreak_derive::Fuzzable;

/// Protocol implementations for various network and communication protocols.
///
/// Contains implementations for USB, TCP and other protocols that can be
/// fuzzed using the Hurtbreak framework.
pub mod protocols;

/// Core attack framework providing both synchronous and asynchronous attack traits.
///
/// Defines the fundamental abstractions for executing attacks, handling responses,
/// and managing attack flow control.
pub mod attack;

pub mod random;

/// Information about a fuzzable field in a struct.
///
/// This struct contains metadata about individual fields that can be used
/// by CLI tools and other consumers to understand field properties and
/// generate appropriate argument parsers.
#[derive(Debug, Clone)]
pub struct FieldInfo {
    pub name: String,
    pub type_name: String,
    pub can_be_fixed: bool,
    pub description: String,
}

/// Trait for types that can expose metadata about their fuzzable fields.
///
/// This trait is automatically implemented by the `#[derive(Fuzzable)]` macro
/// and provides introspection capabilities for CLI tools and other consumers.
pub trait FieldIntrospection {
    /// Returns metadata about all fuzzable fields in the struct.
    fn get_field_info() -> Vec<FieldInfo>;
}

/// Core trait for implementing fuzzing capabilities on data structures.
///
/// Types implementing this trait can have their fields randomly mutated
/// for fuzzing purposes. The implementation is typically derived using
/// the `#[derive(Fuzzable)]` macro with field-level configuration attributes.
///
/// # Examples
///
/// ```rust,norun
/// use hurtbreak_core::{Fuzzable, Protocol};
///
/// #[derive(Fuzzable)]
/// struct TestPacket {
///     #[fuzz(range = "0..=255")]
///     field_a: u8,
///     #[fuzz(max_len = 100)]
///     field_b: Vec<u8>,
/// }
///
/// let mut packet = TestPacket { field_a: 10, field_b: vec![1, 2, 3] };
/// packet.fuzz(); // Randomly mutates field_a and field_b
/// ```
pub trait Fuzzable {
    /// Mutates the implementing type's fields with random values.
    ///
    /// The specific fuzzing behavior depends on the implementation,
    /// which is typically generated by the derive macro based on
    /// field types and `#[fuzz]` attributes.
    fn fuzz(&mut self);

    /// Sets a specific field to a fixed value that won't be fuzzed.
    ///
    /// # Arguments
    ///
    /// * `field_name` - The name of the field to set
    /// * `value` - The string representation of the value to set
    ///
    /// # Returns
    ///
    /// `Ok(())` if the field was successfully set, `Err(String)` with an error message otherwise.
    fn set_field(&mut self, field_name: &str, value: &str) -> Result<(), String>;
}

/// Core trait for protocol implementations that can generate wire-format payloads.
///
/// This trait enables protocol structures to be serialized into byte arrays
/// that represent their on-the-wire format for transmission or analysis.
///
/// # Examples
///
/// ```rust,norun
/// use hurtbreak_core::Protocol;
///
/// struct SimpleProtocol {
///     header: u16,
///     data: Vec<u8>,
/// }
///
/// impl Protocol for SimpleProtocol {
///     fn payload(&self) -> Vec<u8> {
///         let mut buffer = Vec::new();
///         buffer.extend_from_slice(&self.header.to_be_bytes());
///         buffer.extend_from_slice(&self.data);
///         buffer
///     }
/// }
/// ```
pub trait Protocol {
    /// Generates the wire-format representation of the protocol data.
    ///
    /// Returns a byte vector containing the serialized protocol data
    /// suitable for network transmission or analysis.
    fn payload(&self) -> Vec<u8>;
}
